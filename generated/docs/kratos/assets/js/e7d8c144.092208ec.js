(window.webpackJsonp=window.webpackJsonp||[]).push([[335],{1115:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/google-authenticator-backup-codes-ca3b77648bc2932ee1f5e96633640ae3.png"},401:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return c})),r.d(t,"toc",(function(){return i})),r.d(t,"default",(function(){return p}));var o=r(3),n=r(8),a=(r(0),r(454)),s={id:"look-up-secrets",title:"Look-up Secrets and Recovery Codes"},c={unversionedId:"concepts/authenticators/look-up-secrets",id:"concepts/authenticators/look-up-secrets",isDocsHomePage:!1,title:"Look-up Secrets and Recovery Codes",description:"Google Authenticator Backup Codes",source:"@site/docs/concepts/authenticators/look-up-secrets.mdx",sourceDirName:"concepts/authenticators",slug:"/concepts/authenticators/look-up-secrets",permalink:"/kratos/docs/next/concepts/authenticators/look-up-secrets",editUrl:"https://github.com/ory/kratos/edit/master/docs/docs/concepts/authenticators/look-up-secrets.mdx",version:"current",lastUpdatedBy:"aeneasr",lastUpdatedAt:1617992820,formattedLastUpdatedAt:"4/9/2021",frontMatter:{id:"look-up-secrets",title:"Look-up Secrets and Recovery Codes"}},i=[{value:"Resilient to Offline Attacks",id:"resilient-to-offline-attacks",children:[]}],u={toc:i};function p(e){var t=e.components,s=Object(n.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},u,s,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,Object(a.b)("img",{alt:"Google Authenticator Backup Codes",src:r(1115).default})),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},'A look-up secret authenticator is a physical or electronic record that stores\na set of secrets shared between the claimant and the CSP. The claimant uses\nthe authenticator to look up the appropriate secret(s) needed to respond to a\nprompt from the verifier. For example, the verifier may ask a claimant to\nprovide a specific subset of the numeric or character strings printed on a\ncard in table format. A common application of look-up secrets is the use of\n"recovery keys" stored by the subscriber for use in the event another\nauthenticator is lost or malfunctions. A look-up secret is something you\nhave. -\n',Object(a.b)("a",{parentName:"p",href:"https://pages.nist.gov/800-63-3/sp800-63b.html#-512-look-up-secrets"},"Source"))),Object(a.b)("h2",{id:"resilient-to-offline-attacks"},"Resilient to Offline Attacks"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Verifiers SHALL store look-up secrets in a form that is resistant to offline\nattacks. Look-up secrets having at least 112 bits of entropy SHALL be hashed\nwith an approved one-way function as described in Section 5.1.1.2. Look-up\nsecrets with fewer than 112 bits of entropy SHALL be salted and hashed using a\nsuitable one-way key derivation function, also described in Section 5.1.1.2.\nThe salt value SHALL be at least 32 in bits in length and arbitrarily chosen\nso as to minimize salt value collisions among stored hashes. Both the salt\nvalue and the resulting hash SHALL be stored for each look-up secret. -\n",Object(a.b)("a",{parentName:"p",href:"https://pages.nist.gov/800-63-3/sp800-63b.html#5122-look-up-secret-verifiers"},"Source"))))}p.isMDXComponent=!0},454:function(e,t,r){"use strict";r.d(t,"a",(function(){return l})),r.d(t,"b",(function(){return b}));var o=r(0),n=r.n(o);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var u=n.a.createContext({}),p=function(e){var t=n.a.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},l=function(e){var t=p(e.components);return n.a.createElement(u.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},d=n.a.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),l=p(r),d=o,b=l["".concat(s,".").concat(d)]||l[d]||f[d]||a;return r?n.a.createElement(b,c(c({ref:t},u),{},{components:r})):n.a.createElement(b,c({ref:t},u))}));function b(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=d;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:o,s[1]=c;for(var u=2;u<a;u++)s[u]=r[u];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);